# 데이터 타입

## 데이터 타입의 종류

### 기본형

- 값이 담긴 주솟값을 바로 복제
- 불변성
- `Number`, `String`, `Boolean`, `null`, `undefined`, `Symbol`

### 참조형

- 값이 담긴 주솟값들로 이루어진 **묶음을 가리키는 주솟값**을 복제
- `Object`(객체)
  - `Array`, `Function`, `Date`, `RegExp`, `Map`, `WeakMap`, `Set`, `WeakSet`

<br>

## 데이터 타입에 관한 배경지식

0 또는 1만 표현할 수 있는 하나의 메모리 조각을 bit, 비트라고 한다. 메모리는 매우 많은 비트들로 구성되어 있고 각 비트는 고유한 식별자를 통해 위치를 확인할수 있다.

1바이트는 8개의 비트로 구성되어 있다.

모든 데이터는 바이트 단위의 식별자, 메모리 주솟값을 통해 서로 구분하고 연결할 수 있다.

### 식별자와 변수

변수는 변할 수 있는 데이터를 뜻하고 식별자는 어떤 데이터를 식별하는데 사용하는 이름, 변수명이다.

<br>

## 변수 선언과 데이터 할당

```javascript
const a; // 변수 선언
a = 1234; // 데이터 할당
```

변수를 선언하면 컴퓨터는 메모리에서 비어있는 공간 하나를 확보하여 변수 영역의 주소(예시: 1003)와 데이터(이름:a 값: undefined)로 담기게 된다. 그 후 데이터를 할당하게 되면 데이터는 데이터 영역의 주소(예시: 5004)와 데이터(1234)가 담긴다.

변수 데이터를 할당하게 되면 변수 영역에 값: 1234가 되는 것이 아니라 데이터 영역의 주소를 변수 영역에 저장하는 식으로 이루어진다. 즉, 값: @5004라고 저장되는 것이다.

```
💡 만약 문자열 ‘abc’ 데이터에 ‘def’를 추가하라고 하면 컴퓨터는 ‘abc’가 저장된 공간에 ‘abcdef’를 저장하는게 아니라 ‘abcdef’라는 문자열을 새로 만들어 별도의 공간에 저장한다. 그 주소를 변수 공간에 연결한다.
```

<br>

## 기본형 데이터와 참조형 데이터

### 변수와 상수

변경 가능성의 대상은 변수 영역 메모리이다. 다른 데이터를 재할당할 수 있는지 여부

### 불변성 여부

변경 가능성의 대상은 데이터 영역 메모리이다. 기본형 데이터는 모두 불변값이다.

‘abcdef’의 예시로 설명했듯이 변경은 새로 만드는 동작을 통해서만 이루어진다. 다른 값으로 “변경"할 수 없다. 이것이 바로 불변값의 성질이다.

### 가변값

참조형 데이터는 가변값인 경우도 많지만 설정에 따라 변경 불가능한 경우도 있고 불변값으로 활용하는 방법도 있다.

```jsx
const obj1 = {
  a: 1,
  b: "bbb",
};
```

- **변수 영역** 이름: obj1, 값: @5001
- **데이터 영역** 5001: @7103 ~ ?(필요한 시점에 동적으로 확보) / 5003: 1 / 5004: ‘bbb’
- **변수 @5001의 변수 영역** 7103: 이름: a, 값: @5003 / 7104: 이름: b, : @5004

변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하다. 그러나 데이터 할당 과정에서 차이가 있기에 복사 이후의 동작에는 큰 차이가 발생한다.

<br>

## 불변 객체

만일 유저의 이름이 바뀌었고 해당 사실을 알려주어야할 때를 예로 들자면, 원본 참조형 데이터 타입(객체)은 값이 변해서는 안되고 원본을 직접 복사하여 유저의 이름이 바뀌게 한 뒤에 원본 객체와 복사 객체를 비교해야 한다.

### 얕은 복사와 깊은 복사

이 때 얕은 복사와 깊은 복사가 나온다.

- 얕은 복사: 바로 아래 단계의 값만 복사하는 방법, 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사된다.
- 깊은 복사: 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법, 중첩된 객체에서 주솟값이 아닌 데이터를 저장한다.

객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야 한다.

**깊은 복사를 하는 방법**

- 재귀적으로 호출하는 깊은 복사 함수

```javascript
const copyObjectDeep = function (target) {
  var result = {};
  if (typeof target === "object" && target !== null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }
  return result;
};
```

- JSON을 활용한 깊은 복사 함수

```javascript
const copyObjectViaJSON = function (target) {
  return JSON.parse(JSON.stringify(target));
};
```

객체를 JSON 문법으로 표현된 문자열로 전환 했다가 다시 JSON 객체로 바꾼다.  
하지만 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시하므로 순수한 정보만 다룰 때 활용하기 좋다.

<br>

## undefined와 null

없음을 나타낸다.

### undefined

어떤 변수에 값이 존재하지 않을 경우를 의미한다.

1. 값을 대입하지 않은 변수에 접근
2. 객체 내부에 존재하지 않는 프로퍼티에 접근
3. return문이 없거나 호출되지 않는 함수의 실행 결과

```
<비어있는 값과 undefined의 차이>
비어있는 값은 배열 순회에서 제외된다. 비어있는 값 자체가 없는 값으로 판별되기 때문이다.
특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 동작을 한다.
그러나 여기서 직접 undefined라는 값을 지정한다면 배열 순회에 포함된다. 값이 정해져있기 때문이다.
```

이러한 이유로 인해 가급적 직접 undefined를 할당하지 않는 것이 좋다.

### null

바로 이 때 null을 사용해준다. 비어있음을 명시적으로 나타내고 싶을때 사용한다.

대신 typeof를 했을 때 null은 object를 반환하기 때문에 일치 연산자(===)를 사용하여 비교해주면 된다.

```javascript
const n = null;

console.log(n === undefined); // false
console.log(n === null); // true
```
