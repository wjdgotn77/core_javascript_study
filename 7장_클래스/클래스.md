# Class

JS 는 프로토타입 기반 언어이기 때문에 사실 **Class** 라는 개념이 없습니다.

다만, 객체지향언어가 메인 패러다임이기에 Class에 익숙한 개발자들은 JS로 클래스를 구현하려고 노력했습니다.

이에 따라 **ES6**부터 JS는 Class를 지원하게 되었습니다.

그러나 앞서 말했듯, 결국 JS의 Class는 프로토타입을 이용해 구현된 사항입니다.

코어 자바스크립트 도서에서는 ES6의 Class에 대한 문법보다는 프로토타입을 이용해 어떻게 고민하여 클래스를 구현했는가? 에 더 집중했다보니 개인적으로는 크게 알 필요가 있는가? 에 대한 생각이 듭니다.

따라서 여기에 도서의 내용보다는, 제가 개인적으로 알고 있는 Class에 대한 개념을 소개하고자 합니다.

## Class가 뭐야?

Class를 우리는 '수업', '강의' 와 같은 뜻으로 다들 알고 있을 겁니다.

놀랍게도, **'범주' 또는 '부류' 라는 의미**도 갖고 있습니다. CS에서 Class는 그러한 의미로 받아들이면 편합니다.

![image](https://user-images.githubusercontent.com/23470125/160835556-c8b2b2e3-7791-467c-93c2-9c3816298724.png)

예를 들면 위와 같습니다.

모든 객체는 Object 객체로부터 상속되는데, 우리가 '생물' 이라는 객체를 클래스로 구현한다고 합시다.

이 때 '생물'은 **Object의 SubClass**이자 '동물','식물'의 **SuperClass**가 됩니다.

그렇다면 '동물'은 **'포유류','조류'의 SuperClass**이고, **'생물'의 SubClass** 겠죠?

동물은 움직입니다. 포유류나 조류도 움직일거고, 인간과 원숭이와 새 모두 움직일 겁니다.

그러나 각각의 '움직인다'는 다릅니다. 인간은 두 발로, 개는 네 발로, 원숭이는 두 발로, 새는 날개와 두 발로 움직이겠죠.

그렇듯 공통된 동작이 있더라도 각기 다른 동작을 의미하는 이러한 형태를 **함수의 재정의, '오버라이딩'** 이라고 합니다.

이것을 CS적인 용어로 풀이해봅시다.

* 사람이든, 사물이든, 동작이든. **어떠한 범주로 묶을 수 있는 것**을 Class 객체라고 할 수 있다.

* 각 Class는 **각자의 status**가 있다. 즉 Class들은 서로의 status를 **관심가질 이유도, 필요도 없다.**

* 그러므로 객체지향 프로그래밍은 각자의 status를 관리하는 객체들의 동작을 **의미론적으로 평가**하여 프로그램을 구현하자는 패러다임이다.


### Class로 RPG게임을 구현한 예시

전사 (Knight), 몬스터 (Monster) 클래스가 이미 구현되어있다고 치고, 객체지향적인 코드 예시를 보여드립니다.

전사는 본인 위치를 기준으로만 공격할 수 있고 몬스터는 원거리 공격이 가능하다고 가정합니다.

```
const knight = new Knight()
const monster = new Monster()

if (knight.move()){
  if (knight.loc === monster.loc && knight.attack()) monster.hp--;
  else knight.hp--;
}
 // 만약 전사가 움직일 때, 몬스터를 마주쳤고 근접공격을 했다면 몬스터의 체력을 깎는다.
 // 공격키가 누르지않았는데 좌표가 겹친다면 몬스터가 근접공격을 한 것이니 전사의 체력을 깎는다.

if (monster.attack(x,y)){
  const attackPoint = new attack(x,y)
  if (knight.loc === attackPoint.loc) knight.hp--;
  else delete attackPoint
}
 // 몬스터가 원거리 공격을 했다면 해당 공격에 대한 객체를 선언한다.
 // 공격 객체의 좌표가 전사의 좌표와 일치한다면 맞은 걸로 간주하여 전사의 체력을 깎는다.
 // 그렇지 않는다면 공격 객체를 삭제하여 화면 상에서 없애버린다.
 
 // main.js
```

각 객체의 메서드들은 클래스에서 받아올 뿐 프로그램은 그 **메서드들의 동작을 알 필요가 없이 이름만 알면 호출**할 수 있습니다.

이미 클래스에 구현되어 있기 때문에 가져와서 쓰기만 하면 되는거죠.

그리고 전사나 몬스터가 어디에 있는지에 대한 정보 또한 각각의 move() 메서드를 통해 **각 객체가 알아서 관리**합니다.

이런 방식으로 구현하는 것이 OOP(객체지향 프로그래밍)의 형태라고 소개드릴 수 있을 것 같습니다만,

자바를 한지 좀 오래되어 단순히 이러한 형태구나~ 라고 이해만 해주시면 될 것 같습니다. 이 코드는 정답이 아닙니다.

---

### Class를 사용하는 실제 예시

우리는 말보다 코드로 소통하는 것이 더 빠르기에 설명보단 코드를 보여드립니다.

* '종류'를 의미하는 **SuperClass**

  ![image](https://user-images.githubusercontent.com/23470125/160841688-c4cd8d48-ec5e-4d97-beda-c4c23fdda15a.png)

  * Races는 name, hands, legs 라는 멤버변수를 가지고 있습니다.
  
  * 또한 정보를 의미하는 info(), 움직임을 의미하는 move(), 점프를 의미하는 jump() 멤버 메서드가 선언되었습니다.

* **'Races'를 상속받는** Person

  ![image](https://user-images.githubusercontent.com/23470125/160843907-00918b60-436d-4b26-bfde-a502901b0bec.png)

  * Person은 Races를 상속받아 **Races의 멤버 변수와 멤버 메서드를 이미 가지고 있습니다.**
  
  * **super()라는 함수는 부모 클래스의 생성자**를 불러옵니다. 즉, 위와 같은 방식으로 멤버 변수를 구성할 수 있습니다.
  
  * 또한 꼭 부모 클래스의 멤버변수만 가질 필요는 없습니다. 위와 같이 별개의 변수를 선언할 수 있습니다.

* **'Races'를 상속받는** Dog

  ![image](https://user-images.githubusercontent.com/23470125/160842140-e426d550-cfae-4a0e-a8da-da9a755cbc62.png)
  
  * 위의 Person과 설명은 같습니다.

* Class로 인스턴스 선언하기

  ![image](https://user-images.githubusercontent.com/23470125/160842276-09c1b84a-84cb-4926-b6c3-ee2c4a18779c.png)

공통 SuperClass인 Races는 정보, 움직임, 점프 라는 메서드를 가지고 있고 자식 클래스가 재정의할 수 있도록 비워두었습니다.
##### *자바에서는 이것을 추상 클래스(abstract class)라는 개념으로 구현하는데, 그런게 있구나 라고만 알고 계셔요.*

그리고 Person과 Dog은 Races를 받아와 공통 메서드들을 **입맛대로 재정의**합니다.

---

### Class의 멤버 변수에 접근하거나, 수정하려면 어떻게 해야할까?

위의 Person Class의 예시를 들어보겠습니다.

![image](https://user-images.githubusercontent.com/23470125/160877300-29d3ec24-f4ff-4fec-b682-b916a1b3ad6a.png)

Class는 결국 Object prototype을 가리키는 객체이기 때문에 getter, setter 함수를 쓸 수 있습니다.

혹은 set의 역할을 하는 메서드(getName) 를 만들어줘도 상관 없습니다.

그런데 '객체' 이기 때문에, a.locX = 3 이라고 한 것처럼 멤버 변수에 직접 접근해서 수정할 수도 있습니다.
##### *자바에서는 public,protected,private 라는 키워드를 통해 멤버 변수의 접근 권한을 설정할 수 있습니다. 그런게 있구나 라고만 알고 계셔요.*

하지만 이는 객체의 status는 **해당 객체만 관심을 가지면 된다, 라는 규칙에 위배**됩니다.

따라서 **setter 함수를 따로 클래스에 만들어서 설정해주는 것**이 객체지향적입니다.

최종적으로, Person의 인스턴스인 a를 콘솔에 찍어보면 이렇게 나옵니다.

![image](https://user-images.githubusercontent.com/23470125/160878963-c29bb39b-7cee-44a8-b959-c06c86fba741.png)


어라라..? \_\_proto\_\_ 속성이 보이네요?

그렇구나, 결국 JS에서의 Class는 prototype 개념을 이용해 OOP의 Class 개념을 흉내낸 것임을 알 수 있습니다.

---

## Prototype을 이용해 Class를 구현하기.

![image](https://user-images.githubusercontent.com/23470125/160834846-223c61e8-7497-4f74-aa80-49d788a7249b.png)

6장에서 썼던 이미지를 가져왔습니다.

서두에서 설명드린 Class와 굉장히 비슷하죠? 그러나 Prototype과 Class는 '깊은 복사와 얕은 복사'의 차이점과 같은 차이를 가지고 있습니다.

* **Class는 '독립된' 객체. 상속으로 엮인다 한들, 각 객체의 멤버 변수와 메서드 등은 모두 각자가 가진 것이지, 부모의 것을 참조하는 것이 아니다.** 

* **Prototype은 '참조'한다. 원본의 것을 가리킬 뿐이다. 독립된 무언가가 생성되는 것이 아니다.**

그러므로 보편적인 Class의 개념이 JS의 Class와는 분명히 다른 점을 알고, Prototype으로 Class를 흉내낸 코드를 보여드립니다.

![image](https://user-images.githubusercontent.com/23470125/160879162-870d205d-5630-4d59-9771-0ecbd8d711fb.png)

### 특이점

결국 JS의 Class는 Prototype chaining을 이용한 트릭에 불과하고, 각 객체의 접근 권한을 컨트롤하기 어렵습니다.

따라서 이를테면, **delete a.locX** 과 같은 방식으로 객체의 멤버변수를 제거할 수 있습니다.

![image](https://user-images.githubusercontent.com/23470125/160883421-b496e072-76cf-4484-8e69-6c04d62bea67.png)

locX가 delete 되었으니, **상위 프로토타입인 Object에 locX 라는 멤버가 있는지 확인**하게 됩니다.

있을리가 없겠죠? 그래서 당연히 undefined가 출력됩니다.

'#' 이라는 접근제어자로 해결을 할 수는 있습니다.

![image](https://user-images.githubusercontent.com/23470125/160886116-155c0df0-3575-446d-9372-5bb99e9d8b70.png)

> 참고 링크 : http://www.gisdeveloper.co.kr/?p=11697

그러나 비교적 최근 만들어진데다, 보편적인 Class의 문법과는 영 맞지 않아 불편합니다.

이 부분에 대한 이야기가 코어자바스크립트 도서에 나와있습니다.

다만 이해도 잘 안되고, 저자도 크게 신경쓰지 않아도 되는 부분이라고 언급하여 지나가도록 하겠습니다.

---

## Class의 특징 및 요약

* Class도 호이스팅됩니다. 다만, let과 const의 경우를 따라간다고 생각하시면 됩니다.
  * 선언과 초기화 단계가 구분되므로, 일시적 사각지대에 빠져 초기화 시점 이전에는 JS가 접근할 수 없습니다.
  * Class도 선언, 표현식이 따로 존재합니다. 즉, 함수 표현식과 같이 Class 표현식은 호이스팅되지 않습니다.
  
    ```
      class Person {
        constructor(name){
          this.name = name;
        }
      } // 선언식
      
      const Person = class{
        constructor(name){
          this.name = name;
        }
      } // 표현식
    ```
* super() 키워드를 통해 부모 클래스의 생성자를 불러올 수 있습니다.
* extends 키워드로 상속 받을 부모 클래스를 선택합니다.
* 객체이기 때문에 getter, setter의 활용이 가능합니다.
* constructor는 생략될 수도 있습니다.

  ![image](https://user-images.githubusercontent.com/23470125/160881427-fd20ee32-c167-44b0-8c72-6908f2bc69c6.png)

  만약 멤버 변수가 모두 다르고, 공통된 메서드만 존재한다면 위와 같은 방식으로 사용할 수 있을 겁니다.

* 재정의(오버라이딩)을 이용해 부모 클래스에서 선언된 메서드를 자식 클래스에서 다시 만들 수 있습니다.

* 추상화 : 공통된 특징을 범주화하여 표현한 것을 의미합니다. 이를 통해 다른 객체들은 해당 객체의 status를 알 필요가 없는 겁니다.

* 캡슐화 : 각 객체의 status는 해당 객체만 알 수 있습니다. 따라서 각 클래스는 독립적이고 보안성이 좋습니다.

* 상속성 : 공통된 특징이 있는 경우 하나의 부모 클래스를 이용해 여러 자식 클래스를 만들 수 있습니다. 이를 통해 재사용성이 뛰어나며, 다형성을 가집니다.

* 다형성 : 같은 이름임에도 불구하고 다른 동작을 가지거나, 인수를 가질 수 있음을 의미합니다. 이를테면, 사람은 두 발로 이동하고 강아지는 네 발로 이동합니다.
  * 재정의(오버라이딩)을 이용해 다형성을 확보할 수 있습니다.



